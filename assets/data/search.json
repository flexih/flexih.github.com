[ { "title": "Mach-O里的方法", "url": "/posts/Mach-O%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95/", "categories": "iOS, Mach-O", "tags": "", "date": "2020-04-20 00:17:00 +0800", "snippet": "Mach-O里与方法有关的Load Command有两种类型，LC_MAIN 和 LC_FUNCTION_STARTS。####LC_MAINLC_MAIN是描述可执行文件的入口函数int main(int argc, char * argv[])的，它的定义如下：123456struct entry_point_command { uint32_t cmd; /* LC_MAIN only used in MH_EXECUTE filetypes */ uint32_t cmdsize; /* 24 */ uint64_t entryoff; /* file (..." }, { "title": "从《一个不规范的 Category 写法导致的“血案”》说起—检查分类同名方法", "url": "/posts/%E6%A3%80%E6%9F%A5%E5%88%86%E7%B1%BB%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95/", "categories": "iOS, Mach-O", "tags": "", "date": "2020-03-30 19:18:30 +0800", "snippet": "前几天有一篇文章一个不规范的 Category 写法导致的“血案”，很有意思。测试代码如下：1234567891011121314//NSObject+Test.h@interface NSObject (Test)- (void)func;@end@implementation NSObject (Test)- (void)func { printf(&quot;hello, world&quot;);}@end在两个.m文件里引用了NSObject+Test.h，查看Mach-O信息：12345678910111213Contents of (__DATA_CONST,__ob..." }, { "title": "Objective-C二进制瘦身", "url": "/posts/Objective-C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%98%A6%E8%BA%AB/", "categories": "iOS, Mach-O", "tags": "瘦身, Mach-O", "date": "2020-02-04 22:55:48 +0800", "snippet": "先说结论：我写了个工具检测无用方法、无用类以及无用协议，只需要Mach-O文件，对Build Setting里的Strip Style无要求，Snake。Objective-C是采用消息发送的方式来实现类方法的调用。消息发送使用“查表”的方式实现从方法名到方法实现的定位。因此在编译的时候编译器不能确知一个方法是否真的被调用，也就无法像C语言一样只编译使用到的方法。也因此造成了目标二进制里包含没有使用的类、没有使用的方法、以及没有使用的协议等。为了实现消息发送，Objective-C的编译器会在编译的时候自动生成相关的结构体变量，来存储类的信息，这些信息也被称作ObjC元信息。clang命..." }, { "title": "iOS如何监测网络请求", "url": "/posts/iOS%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/", "categories": "iOS", "tags": "", "date": "2019-07-03 16:36:00 +0800", "snippet": "iOS10 NSURLSession的delegate NSURLSessionTaskDelegate增加了1- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));在NSURLSessionTaskMetrics里的NSURLSessionTa..." }, { "title": "使用Clang插件", "url": "/posts/%E4%BD%BF%E7%94%A8Clang%E6%8F%92%E4%BB%B6/", "categories": "iOS", "tags": "clang", "date": "2019-06-04 12:27:18 +0800", "snippet": "最近在把一个功能模块从一个独立的项目迁入另一个大型项目中，要求这个功能模块只在某一业务的页面上开启。首先想到的方法是判断一个页面的类是否属于该业务。对于dynamic framework可以通过NSBundle方法判断1+ (NSBundle *)bundleForClass:(Class)aClass;对于static链接的framework或者library无法使用这种方式。只能换一种思路，通过正则搜索代码里哪些类继承自UIViewController，但是对于继承UIViewController的子类，这种手工搜索方式就显得捉襟见肘了。然后想到能不能在编译的时候，去获得UIView..." }, { "title": "为iOS点击增加触控反馈", "url": "/posts/%E4%B8%BAiOS%E7%82%B9%E5%87%BB%E5%A2%9E%E5%8A%A0%E8%A7%A6%E6%8E%A7%E5%8F%8D%E9%A6%88/", "categories": "iOS", "tags": "", "date": "2019-03-10 23:54:41 +0800", "snippet": "iOS 10增加了触控反馈的类UIFeedbackGenerator及其子类，使得触控反馈不再只能使用私有的sound id。这里不再赘述触控反馈本身，而是提出一种通用的办法为比如UIButton增加触控反馈。示例代码FeedbackDemo在Github。UIApplication类有一个方法：1func sendAction(_ action: Selector, to target: Any?, from sender: Any?, for event: UIEvent?) -&amp;gt; Bool其注释如下：1Normally, this method is invoked ..." }, { "title": "通过MachO分析App技术栈", "url": "/posts/%E9%80%9A%E8%BF%87MachO%E5%88%86%E6%9E%90App%E6%8A%80%E6%9C%AF%E6%A0%88/", "categories": "iOS, Mach-O", "tags": "Flutter, React Native, Swift", "date": "2019-03-08 16:05:00 +0800", "snippet": "标题里的技术栈特指App里Swift/React Native/Flutter/Weex的应用情况。####实现 Swiftdyld libs里是否包含libswiftCore.dylib React Native是否有包含RCTView类 Flutterdyld libs里是否包含Flutter.framework Weex是否有包含WXSDKInstance类 dyld libs指类型为LC_LOAD_DYLIB的load command。在实现的时候，有两点需要注意： 需要对binary，binary引用的dyld Frame..." }, { "title": "iOS无埋点数据采集实践", "url": "/posts/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%AE%9E%E8%B7%B5/", "categories": "iOS", "tags": "无埋点", "date": "2019-03-02 22:46:00 +0800", "snippet": "无埋点又称全埋点或者零埋点，虽然叫法不一样，想要到达的目的是一样的，即数据收集不再需要hard code，甚至可以做到动态可配要收集的数据。这里不讨论无埋点的方案细节，只探讨实践过程中遇到的几个点。目前看到网上的资料里提出的方案还有提升的空间。下面具体分析一下。######1.UITableViewCell的点击事件1UIKIT_EXTERN NSNotificationName const UITableViewSelectionDidChangeNotification;如通知的名字所示UITableViewCell被选中的时候会发通知，监听此通知即可收集UITableViewCel..." } ]
