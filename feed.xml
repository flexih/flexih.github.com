<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://flexih.github.io</id><title>flexih's blog</title><subtitle>flexih's blog, about code and life.</subtitle> <updated>2020-05-31T18:12:59+08:00</updated> <author> <name>flexih</name> <uri>https://flexih.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://flexih.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.1.0">Jekyll</generator> <rights> © 2020 flexih </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Mach-O里的方法</title><link href="https://flexih.github.io/posts/Mach-O%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html" title="Mach-O里的方法" /><published>2020-04-20T00:17:00+08:00</published> <updated>2020-05-31T18:12:59+08:00</updated> <id>https://flexih.github.io/posts/Mach-O%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95/</id> <content src="https://flexih.github.io/posts/Mach-O%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95/" /> <author> <name>flexih</name> </author> <category term="iOS" /> <category term="Mach-O" /> <summary> Mach-O里与方法有关的Load Command有两种类型，LC_MAIN 和 LC_FUNCTION_STARTS。 ####LC_MAIN LC_MAIN是描述可执行文件的入口函数int main(int argc, char * argv[])的，它的定义如下： 1 2 3 4 5 6 struct entry_point_command { uint32_t cmd; ...</summary> </entry> <entry><title>从《一个不规范的 Category 写法导致的“血案”》说起—检查分类同名方法</title><link href="https://flexih.github.io/posts/%E6%A3%80%E6%9F%A5%E5%88%86%E7%B1%BB%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html" title="从《一个不规范的 Category 写法导致的“血案”》说起—检查分类同名方法" /><published>2020-03-30T19:18:30+08:00</published> <updated>2020-05-31T18:12:59+08:00</updated> <id>https://flexih.github.io/posts/%E6%A3%80%E6%9F%A5%E5%88%86%E7%B1%BB%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95/</id> <content src="https://flexih.github.io/posts/%E6%A3%80%E6%9F%A5%E5%88%86%E7%B1%BB%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95/" /> <author> <name>flexih</name> </author> <category term="iOS" /> <category term="Mach-O" /> <summary> 前几天有一篇文章一个不规范的 Category 写法导致的“血案”，很有意思。 测试代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //NSObject+Test.h @interface NSObject (Test) - (void)func; @end @implementation NSObject (Test) - (void)func { ...</summary> </entry> <entry><title>Objective-C二进制瘦身</title><link href="https://flexih.github.io/posts/Objective-C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%98%A6%E8%BA%AB/" rel="alternate" type="text/html" title="Objective-C二进制瘦身" /><published>2020-02-04T22:55:48+08:00</published> <updated>2020-05-31T18:12:59+08:00</updated> <id>https://flexih.github.io/posts/Objective-C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%98%A6%E8%BA%AB/</id> <content src="https://flexih.github.io/posts/Objective-C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%98%A6%E8%BA%AB/" /> <author> <name>flexih</name> </author> <category term="iOS" /> <category term="Mach-O" /> <summary> 先说结论：我写了个工具检测无用方法、无用类以及无用协议，只需要Mach-O文件，对Build Setting里的Strip Style无要求，Snake。 Objective-C是采用消息发送的方式来实现类方法的调用。消息发送使用“查表”的方式实现从方法名到方法实现的定位。因此在编译的时候编译器不能确知一个方法是否真的被调用，也就无法像C语言一样只编译使用到的方法。也因此造成了目标二进制里...</summary> </entry> <entry><title>iOS如何监测网络请求</title><link href="https://flexih.github.io/posts/iOS%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" rel="alternate" type="text/html" title="iOS如何监测网络请求" /><published>2019-07-03T16:36:00+08:00</published> <updated>2020-05-31T18:12:59+08:00</updated> <id>https://flexih.github.io/posts/iOS%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</id> <content src="https://flexih.github.io/posts/iOS%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" /> <author> <name>flexih</name> </author> <category term="iOS" /> <summary> iOS10 NSURLSession的delegate NSURLSessionTaskDelegate增加了 1 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_...</summary> </entry> <entry><title>使用Clang插件</title><link href="https://flexih.github.io/posts/%E4%BD%BF%E7%94%A8Clang%E6%8F%92%E4%BB%B6/" rel="alternate" type="text/html" title="使用Clang插件" /><published>2019-06-04T12:27:18+08:00</published> <updated>2020-05-31T18:12:59+08:00</updated> <id>https://flexih.github.io/posts/%E4%BD%BF%E7%94%A8Clang%E6%8F%92%E4%BB%B6/</id> <content src="https://flexih.github.io/posts/%E4%BD%BF%E7%94%A8Clang%E6%8F%92%E4%BB%B6/" /> <author> <name>flexih</name> </author> <category term="iOS" /> <summary> 最近在把一个功能模块从一个独立的项目迁入另一个大型项目中，要求这个功能模块只在某一业务的页面上开启。 首先想到的方法是判断一个页面的类是否属于该业务。对于dynamic framework可以通过NSBundle方法判断 1 + (NSBundle *)bundleForClass:(Class)aClass; 对于static链接的framework或者library无法使用这种方式。 ...</summary> </entry> </feed>
